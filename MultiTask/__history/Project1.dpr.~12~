program MultiTask;

{$APPTYPE CONSOLE}

uses
  SysUtils,
  Classes,
  Windows;

type
  TTaskThread = class(TThread)
  private
    FTaskIndex: Integer;
    FResult: Integer;
  protected
    procedure Execute; override;
  public
    constructor Create(TaskIndex: Integer);
    property Result: Integer read FResult;
  end;

constructor TTaskThread.Create(TaskIndex: Integer);
begin
  FTaskIndex := TaskIndex;
  inherited Create(False);
end;

procedure TTaskThread.Execute;
begin
  Sleep(Random(5) * 1000);
  if FTaskIndex = 2 then

    raise Exception.Create(Format('Task %d failed', [FTaskIndex]));
  FResult := (FTaskIndex + 1) * 10;
end;


var
  I: Integer;
  FTasks: array of TTaskThread;


begin
  Randomize;
  SetLength(FTasks, 5);

  for I := 0 to High(FTasks) do
    FTasks[I] := TTaskThread.Create(I);

  var
    ThreadHandles: array of THandle;


  begin
    SetLength(ThreadHandles, Length(FTasks));
    for I:= 0 to High(FTasks) do
      ThreadHandles[I]:= FTasks[I].Handle;
    WaitForMultipleObjects(Length(ThreadHandles), @ThreadHandles[0], True, INFINITE);
    for I:= 0 to High(FTasks) do
    begin
     {try
       Writeln('Task ', I, ' result: ', FTasks[I].Result)

      except
        on E: Exception do
         Writeln('Error in Task ',I,': ', E.Message);

     end;   }
      if FTasks[I].FatalException <> nil then
        Writeln('Error in Task ',I,': ', Exception(FTasks[I].Fatalexception).Message)
      else
         Writeln('Task ', I, ' result: ', FTasks[I].Result)
    end;


    for I:= 0 to High(FTasks) do
      FTasks[I].Free;

   end;
  readln;
end.

